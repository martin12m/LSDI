# ##testing on a single table
# import numpy as np
# import pandas as pd
# import torch
# import torch.nn as nn
# import torch.optim as optim
# from torch.utils.data import Dataset, DataLoader
# import os
# import pickle

# # Paths to data
# relational_folder = "relational_tables"
# non_relational_folder = "transformed_datasets"
# labels_path = "labelsTEST.csv"


# def preprocess_single_table(df, target_size=1024):
#     df = df.select_dtypes(include=[np.number]).fillna(0)
#     flat_array = df.to_numpy(dtype=np.float32).flatten()
#     if len(flat_array) > target_size:
#         flat_array = flat_array[:target_size]
#     else:
#         flat_array = np.pad(flat_array, (0, target_size - len(flat_array)), mode="constant")
#     flat_array = torch.tensor(flat_array, dtype=torch.float32)
#     return flat_array

# # Load your new relational and non-relational tables
# new_table_id = "table_103"  # Replace with your table ID
# relational_path = os.path.join(relational_folder, f"{new_table_id}.csv")
# non_relational_path = os.path.join(non_relational_folder, f"non_relational_{new_table_id}.csv")

# relational = pd.read_csv(relational_path)
# non_relational = pd.read_csv(non_relational_path)

# # Preprocess
# non_relational_tensor = preprocess_single_table(non_relational).to(device)

# # Add batch dimension
# non_relational_tensor = non_relational_tensor.unsqueeze(0)  # Shape: [1, 1024]

# # Make prediction
# with torch.no_grad():
#     output = model(non_relational_tensor)
#     _, predicted_class = torch.max(output.data, 1)

# print(f'Predicted Transformation Class: {predicted_class.item()}')


# # 0=pivot
# # 1=transpose
# # 2=unstack
# # 3=wide_to_long




import numpy as np
import pandas as pd
import torch
import os

# Define a function to preprocess a single table
def preprocess_table(df, target_size=1024):
    # Select only numeric columns and fill NaN values with 0
    df = df.select_dtypes(include=[np.number]).fillna(0)
    
    # Flatten the DataFrame to a 1D array
    flat_array = df.to_numpy(dtype=np.float32).flatten()
    
    # Pad or truncate the array to the target size
    if len(flat_array) > target_size:
        flat_array = flat_array[:target_size]
    else:
        flat_array = np.pad(flat_array, (0, target_size - len(flat_array)), mode="constant")
    
    return torch.tensor(flat_array, dtype=torch.float32)

# Define a function to load and preprocess the data
def load_and_preprocess_data(table_id, relational_folder, non_relational_folder):
    relational_path = os.path.join(relational_folder, f"{table_id}.csv")
    non_relational_path = os.path.join(non_relational_folder, f"non_relational_{table_id}.csv")
    
   
    relational_data = pd.read_csv(relational_path)
    non_relational_data = pd.read_csv(non_relational_path)
    
   
    non_relational_tensor = preprocess_table(non_relational_data)
    
  
    non_relational_tensor = non_relational_tensor.unsqueeze(0)  # Shape: [1, 1024]
    
    return non_relational_tensor


def make_prediction(model, data_tensor):
    with torch.no_grad():
        output = model(data_tensor)
        _, predicted_class = torch.max(output.data, 1)
    return predicted_class.item()


def main():
   
    relational_folder = "relational_tables"
    non_relational_folder = "transformed_datasets"
    table_id = "table_103"  # Replace with your table ID
    non_relational_tensor = load_and_preprocess_data(table_id, relational_folder, non_relational_folder)
    predicted_class = make_prediction(model, non_relational_tensor)
    print(f'Predicted Transformation Class: {predicted_class}')


if __name__ == "__main__":
    main()